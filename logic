
STRUCTURES DE SALLES
hash table / red trees

PARSING ELEMS
2-1 and 1-2 are the same link

PARSING ERRORS
room points to itself
room has same name
room has same coords
no start
no end
isolated room
more than int max rooms

PARTICULAR CASES
start points to end: 1 turn
same link twice (check if room already in children before adding)

MAX PATHS
min number of rooms at any given level between start and end

ABSOLUTE MAX LEN
the absolute max len is the len accepted with the shortest path alone, as any valid
	added path will improve the number of turns and thus reduce max len, so it
	is logical that the max len for the worst scenario (nb path = 1) is absolute
given S the length of short path, A the number of ants:
the first ant takes S turns to get to end. then, all other ants (A - 1) need 1
	turn to step in (because there is one path)
maxlen = S + A - 1

LOAD BALANCING
we start with a number of turns = 0, remaining ants = max ants, and a load = 0,
	on the longest path
we know that to not be late we have to limit the numnber of ants on the path and
	keep at least the difference between the current path and the shortest path
	of ants in reserve
so we take out these, and we divide the rest between the live paths
when we do that we have the number of turns that this path (and all the shorter
ones) have to live
thus we know that for this number of turns this path and the
shorter ones all take one ant per turn
thus we know how many ants are gone when we "kill" this path, and that it has
taken the max number of ants to not be late
====
ants = max ants, live paths = max paths, turns = 0
while (live_paths)
	added_turns = (ants - (len_path - shortest)) / live_paths
	ants = ants - live_paths * added_turns
	turns = turns + added_turns
	path_turns = turns
	live_paths = live_paths - 1

DE LA LONGUEUR DES CHEMINS
kill dead rooms doit se lancer quand on trouve un chemin trop long
il faut balance load de current config a chaque ajout de chemin
il faut s'assurer que la longueur du chemin est bien prise en compte avant de valider une next room

PATH SEEKING
possible paths will be explored iteratively, starting from end
when a branch is closed, we double back on it and mark the 

on ecrase a l'infini

quand on toruve un chemin, on note la salle parent de end sur laquelle on a le plus marchÃ© ;  si a un oment donne toutes les salles parents de end on atteint ce niveau + 2 on arrete l'algo

on travaille sur une config appelee current_config, et on modifie la chaine lem->config_lst via cette config

quand on trouve un chemin, on regarde le nombre de chemins actifs de current_config ; si il est plus grand que celui de lem->config_lst->first->content on lstadd_new(lem->config_lst, current_config), sinon on regarde dans lem->config_lst si la config valide avec le meme nombre de chemin a plus de tours et si oui free son content et on le remplace par current config

PRIORITE DE SALLES
 - on ne depasse pas max len
 - on marche en priorite vers les salles ou on est le moins passe
 - entre deux salles ou on est autant passes, on marche vers la plus proche de
 	start
 - si on a atteint max paths on s'arrete

DISPATCHING:
quand on utilise une config, on desactive des chemins au fur et a mesure
quand on arrive au meme nombre de chemins que la config d'en dessous il faut
	comparer le nimbre de tours restants de la config active au nombre de tours
	total de la config d'apres
si la config d'apres est plus efficace, il faut peut etre passer dessus
	MAIS: attention aux bouchons si on se rattrape sur des chemins qui se coupent
